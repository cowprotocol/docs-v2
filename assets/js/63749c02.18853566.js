"use strict";(self.webpackChunkcow_docs=self.webpackChunkcow_docs||[]).push([[5484],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=a.createContext({}),l=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=l(e.components);return a.createElement(d.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=l(t),m=r,h=c["".concat(d,".").concat(m)]||c[m]||u[m]||o;return t?a.createElement(h,i(i({ref:n},p),{},{components:t})):a.createElement(h,i({ref:n},p))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var d in n)hasOwnProperty.call(n,d)&&(s[d]=n[d]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=t[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},92337:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=t(87462),r=(t(67294),t(3905));const o={},i="Permit, Swap & Bridge CoW Hook",s={unversionedId:"overview/cow-hooks/cow-hooks-example/permit-swap-and-bridge-cow-hook",id:"overview/cow-hooks/cow-hooks-example/permit-swap-and-bridge-cow-hook",title:"Permit, Swap & Bridge CoW Hook",description:"Now that we have the setup out of the way, lets make use of CoW Hooks to set up an order that, when executed will:",source:"@site/docs/overview/cow-hooks/cow-hooks-example/permit-swap-and-bridge-cow-hook.md",sourceDirName:"overview/cow-hooks/cow-hooks-example",slug:"/overview/cow-hooks/cow-hooks-example/permit-swap-and-bridge-cow-hook",permalink:"/docs-v2/docs/overview/cow-hooks/cow-hooks-example/permit-swap-and-bridge-cow-hook",draft:!1,editUrl:"https://github.com/cowprotocol/docs/tree/main/docs/overview/cow-hooks/cow-hooks-example/permit-swap-and-bridge-cow-hook.md",tags:[],version:"current",frontMatter:{}},d={},l=[{value:"EIP-2612 Permit",id:"eip-2612-permit",level:2},{value:"Token Bridging",id:"token-bridging",level:2},{value:"On-chain",id:"on-chain",level:3},{value:"Off-chain",id:"off-chain",level:3},{value:"Order Creation",id:"order-creation",level:2},{value:"Ready, Action",id:"ready-action",level:2}],p={toc:l},c="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"permit-swap--bridge-cow-hook"},"Permit, Swap & Bridge CoW Hook"),(0,r.kt)("p",null,"Now that we have the setup out of the way, lets make use of CoW Hooks to set up an order that, when executed will:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Set the required token approval to CoW Protocol - this allows the user to trade regardless of whether or not they have Ether to execute the approval transaction themselves and so that the approval is only set if the order were to execute (no reason to pay for an approval that doesn\u2019t get used amirite?). Note that this requires a token that has EIP-2612 permit support (such as COW, USDC, and DAI; many modern tokens support this)."),(0,r.kt)("li",{parentName:"ol"},"Bridges the resulting trade proceeds to Gnosis Chain")),(0,r.kt)("h2",{id:"eip-2612-permit"},"EIP-2612 Permit"),(0,r.kt)("p",null,"The next order of business is to compute the pre-hook for setting the required approval of the CoW Protocol Vault Relayer contract."),(0,r.kt)("p",null,"For this, we make use of EIP-2612 permit. This EIP defines an extension for ERC-20 tokens that allows any account to set ERC-20 approvals on behalf of another with an off-chain signature. In other words, we can sign with an off-chain signature permission for anyone to set a single approval to CoW Protocol for us. This signature can be used in a pre-hook so that a solver can execute the approval on your behalf only if your order were to trade."),(0,r.kt)("p",null,"Let's compute the ",(0,r.kt)("inlineCode",{parentName:"p"},"permit")," parameters and sign them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const permit = {\n  owner: wallet.address,\n  spender: VAULT_RELAYER.address,\n  value: orderParams.sellAmount,\n  nonce: await USDC.nonces(wallet.address),\n  deadline: ethers.constants.MaxUint256,\n};\nconst permitSignature = ethers.utils.splitSignature(\n  await wallet._signTypedData(\n    {\n      name: await USDC.name(),\n      version: await USDC.version(),\n      chainId,\n      verifyingContract: USDC.address,\n    },\n    {\n      Permit: [\n        { name: "owner", type: "address" },\n        { name: "spender", type: "address" },\n        { name: "value", type: "uint256" },\n        { name: "nonce", type: "uint256" },\n        { name: "deadline", type: "uint256" },\n      ],\n    },\n    permit,\n  ),\n);\n')),(0,r.kt)("p",null,"And finally, we can build our ",(0,r.kt)("inlineCode",{parentName:"p"},"permit")," pre-hook:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const permitParams = [\n  permit.owner,\n  permit.spender,\n  permit.value,\n  permit.deadline,\n  permitSignature.v,\n  permitSignature.r,\n  permitSignature.s,\n];\nconst permitHook = {\n  target: USDC.address,\n  callData: USDC.interface.encodeFunctionData("permit", permitParams),\n  gasLimit: `${await USDC.estimateGas.permit(...permitParams)}`,\n};\n')),(0,r.kt)("h2",{id:"token-bridging"},"Token Bridging"),(0,r.kt)("p",null,"\u26a0\ufe0f This example makes use of an unaudited contract, use at your own risk!."),(0,r.kt)("h3",{id:"on-chain"},"On-chain"),(0,r.kt)("p",null,"Now, we want to add a post-hook to bridge the funds that we receive from trading over to Gnosis Chain."),(0,r.kt)("p",null,'Unfortunately, bridging contracts aren\'t designed with this use-case in mind. In particular, the hooks are called from an unprivileged context (specifically, the settlement will "trampoline" the user-specified hooks over an intermediary contract as a security measure):'),(0,r.kt)("figure",null,(0,r.kt)("img",{src:"../../../img/image.png",alt:""}),(0,r.kt)("figcaption",null)),(0,r.kt)("p",null,"The existing Gnosis Chain ",(0,r.kt)("inlineCode",{parentName:"p"},"Omnibridge")," contract takes tokens for bridging from ",(0,r.kt)("inlineCode",{parentName:"p"},"msg.sender"),", so we need to design an on-chain contract to temporarily hold the funds for the bridging process. Fortunately, this is very easy to do:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"contract BridgeAccount {\n    address public immutable user;\n    address public immutable omnibridge;\n\n    constructor(address user_, address omnibridge_) {\n        user = user_;\n        omnibridge = omnibridge_;\n    }\n\n    function bridge(address token, uint256 amount) external {\n        IERC20(token).approve(omnibridge, amount);\n        IOmnibridge(omnibridge).relayTokens(token, user, amount);\n    }\n\n    function withdraw(address token, uint256 amount) external {\n        IERC20(token).transfer(user, amount);\n    }\n}\n")),(0,r.kt)("p",null,'This contract works by deploying a per-user "bridging account", where funds deposited can only be bridged to the user, or withdrawn back to the user, keeping the funds safe!'),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that there are no on-chain guarantees that order hooks will get executed as part of a settlement. These are guaranteed by off-chain protocol rules where damages will be taken from solver bonding pools (which sets an upper bound for how much in funds is protected). Keep this in mind as you design your hooks.")),(0,r.kt)("p",null,"In addition to this contract, we also create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Bridger")," factory contract that deploys accounts per user and makes bridging with hooks easier. For the full source code, see ",(0,r.kt)("a",{parentName:"p",href:"https://etherscan.io/address/0xe71ccc8d4e0a298e1300a702ad0ac93303dc8ae5#code"},(0,r.kt)("inlineCode",{parentName:"a"},"[contracts/Bridger.sol]")),"."),(0,r.kt)("p",null,"This can be extended to allow for bridging to different receivers, this is left as an exercise to the reader"),(0,r.kt)("h3",{id:"off-chain"},"Off-chain"),(0,r.kt)("p",null,"Now that we have our bridging intermediary contract, we can generate the hook for bridging the funds received from trading."),(0,r.kt)("p",null,"This is a walk in the park, just compute the receiver address and generate data for the hook:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'orderConfig.receiver = await BRIDGER.getAccountAddress(wallet.address);\nconst bridgeHook = {\n  target: BRIDGER.address,\n  callData: BRIDGER.interface.encodeFunctionData("bridgeAll", [\n    wallet.address,\n    COW.address,\n  ]),\n  // Approximate gas limit determined with Tenderly.\n  gasLimit: "228533",\n};\n')),(0,r.kt)("h2",{id:"order-creation"},"Order Creation"),(0,r.kt)("p",null,"Now that we have our hooks set up, it is time to create our order!"),(0,r.kt)("p",null,"First, we need to include our hooks in the order's ",(0,r.kt)("inlineCode",{parentName:"p"},"appData"),". Hooks are specified as part of ",(0,r.kt)("a",{parentName:"p",href:"https://docs.cow.fi/front-end/creating-app-ids"},(0,r.kt)("inlineCode",{parentName:"a"},"appData")," documents"),(0,r.kt)("a",{parentName:"p",href:"https://docs.cow.fi/front-end/creating-app-ids/create-the-order-meta-data-file/additional-order-preferences"}," "),"in order to ensure that hook preferences are signed by the order:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"orderConfig.appData = JSON.stringify({\n  metadata: {\n    hooks: {\n      pre: [permitHook],\n      post: [bridgeHook],\n    },\n  },\n});\n")),(0,r.kt)("p",null,"Now, lets get a quote for our order:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const { id: quoteId, quote } = await fetch(\n  "https://barn.api.cow.fi/mainnet/api/v1/quote",\n  {\n    method: "POST",\n    headers: {\n      "content-type": "application/json",\n    },\n    body: JSON.stringify({\n      from: wallet.address,\n      sellAmountBeforeFees: orderConfig.sellAmount,\n      ...orderConfig,\n    }),\n  },\n).then((response) => response.json());\nconsole.log("quote:", quoteId, quote);\n')),(0,r.kt)("p",null,"Note that the API will compute a ",(0,r.kt)("inlineCode",{parentName:"p"},"feeAmount")," that takes the hook gas amounts into account. This means that gas for the ",(0,r.kt)("inlineCode",{parentName:"p"},"permit")," and bridging transactions are paid in the sell token only if (and when) the order executes! Account abstraction at its finest \ud83d\ude04."),(0,r.kt)("p",null,"Now all we need to do is sign the order:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const orderData = {\n  ...orderConfig,\n  sellAmount: quote.sellAmount,\n  buyAmount: `${ethers.BigNumber.from(quote.buyAmount).mul(99).div(100)}`,\n  validTo: quote.validTo,\n  appData: ethers.utils.id(orderConfig.appData),\n  feeAmount: quote.feeAmount,\n};\nconst orderSignature = await wallet._signTypedData(\n  {\n    name: "Gnosis Protocol",\n    version: "v2",\n    chainId,\n    verifyingContract: SETTLEMENT.address,\n  },\n  {\n    Order: [\n      { name: "sellToken", type: "address" },\n      { name: "buyToken", type: "address" },\n      { name: "receiver", type: "address" },\n      { name: "sellAmount", type: "uint256" },\n      { name: "buyAmount", type: "uint256" },\n      { name: "validTo", type: "uint32" },\n      { name: "appData", type: "bytes32" },\n      { name: "feeAmount", type: "uint256" },\n      { name: "kind", type: "string" },\n      { name: "partiallyFillable", type: "bool" },\n      { name: "sellTokenBalance", type: "string" },\n      { name: "buyTokenBalance", type: "string" },\n    ],\n  },\n  orderData,\n);\n')),(0,r.kt)("p",null,"And submit it to the API:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const orderUid = await fetch(\n  "https://barn.api.cow.fi/mainnet/api/v1/orders",\n  {\n    method: "POST",\n    headers: {\n      "content-type": "application/json",\n    },\n    body: JSON.stringify({\n      ...orderData,\n      from: wallet.address,\n      appData: orderConfig.appData,\n      appDataHash: orderData.appData,\n      signingScheme: "eip712",\n      signature: orderSignature,\n      quoteId,\n    }),\n  },\n).then((response) => response.json());\nconsole.log("order:", orderUid);\n')),(0,r.kt)("h2",{id:"ready-action"},"Ready, Action"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://youtu.be/FT36lWtC1Oc",alt:null})),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://explorer.cow.fi/orders/0xa4a6be09da793762bbeb8e55d1641c52c83e5a441388f5578f7038ab6c4073b4d0a3a35ddce358bfc4f706e6040c17a50a2e3ba564a7e172?tab=overview"},"Here")," is the demo executed order on Mainnet. As you can see from the ",(0,r.kt)("a",{parentName:"p",href:"https://etherscan.io/tx/0x5c7f61a9364efdc841d680be88c0bd33ab6609b518f9c62df04e26fa356c57ac#eventlog"},"transaction"),", the USDC approval to CoW Protocol was set just-in-time for the swap to happen, and the trade proceeds were sent to the Omnibridge so that the bridging of the COW tokens that were received was initiated."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://gnosisscan.io/tx/0x9979234fb3b5416c6413f75374cbe79354bcc212fa82fb5537506afcc1693f3c"},"Here")," are the relayed COW tokens to the same address on Gnosis Chain."),(0,r.kt)("p",null,"Here is the complete code listing for the script that was used for creating the order."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"index.js"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'import { ethers } from "https://unpkg.com/ethers@5.7.2/dist/ethers.esm.js";\n\n/*** Configuration ***/\n\nconst provider = new ethers.providers.JsonRpcProvider(Deno.env.get("NODE_URL"));\nconst wallet = new ethers.Wallet(Deno.env.get("PRIVATE_KEY"), provider);\n\nconst { chainId } = await provider.getNetwork();\nconsole.log(`connected to chain ${chainId} with account ${wallet.address}`);\n\n/*** Contracts ***/\n\nconst SETTLEMENT = new ethers.Contract(\n  "0x9008D19f58AAbD9eD0D60971565AA8510560ab41",\n  [],\n  provider,\n);\n\nconst VAULT_RELAYER = new ethers.Contract(\n  "0xC92E8bdf79f0507f65a392b0ab4667716BFE0110",\n  [],\n  provider,\n);\n\nconst COW = new ethers.Contract(\n  "0xDEf1CA1fb7FBcDC777520aa7f396b4E015F497aB",\n  [],\n  provider,\n);\n\nconst USDC = new ethers.Contract(\n  "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",\n  [\n    `\n      function decimals() view returns (uint8)\n    `,\n    `\n      function name() view returns (string)\n    `,\n    `\n      function version() view returns (string)\n    `,\n    `\n      function nonces(address owner) view returns (uint256)\n    `,\n    `\n      function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n      )\n    `,\n  ],\n  provider,\n);\n\nconst BRIDGER = new ethers.Contract(\n  "0xE71CcC8d4e0a298E1300a702ad0Ac93303dc8Ae5",\n  [\n    `\n      function getAccountAddress(address user) view returns (address)\n    `,\n    `\n      function bridgeAll(address user, address token)\n    `,\n  ],\n  provider,\n);\n\n/*** Order Configuration ***/\n\nconst orderConfig = {\n  sellToken: USDC.address,\n  buyToken: COW.address,\n  sellAmount: `${ethers.utils.parseUnits("200.0", await USDC.decimals())}`,\n  kind: "sell",\n  partiallyFillable: false,\n  sellTokenBalance: "erc20",\n  buyTokenBalance: "erc20",\n};\n\n/*** EIP-2612 Permit ***/\n\nconst permit = {\n  owner: wallet.address,\n  spender: VAULT_RELAYER.address,\n  value: orderConfig.sellAmount,\n  nonce: await USDC.nonces(wallet.address),\n  deadline: ethers.constants.MaxUint256,\n};\nconst permitSignature = ethers.utils.splitSignature(\n  await wallet._signTypedData(\n    {\n      name: await USDC.name(),\n      version: await USDC.version(),\n      chainId,\n      verifyingContract: USDC.address,\n    },\n    {\n      Permit: [\n        { name: "owner", type: "address" },\n        { name: "spender", type: "address" },\n        { name: "value", type: "uint256" },\n        { name: "nonce", type: "uint256" },\n        { name: "deadline", type: "uint256" },\n      ],\n    },\n    permit,\n  ),\n);\nconst permitParams = [\n  permit.owner,\n  permit.spender,\n  permit.value,\n  permit.deadline,\n  permitSignature.v,\n  permitSignature.r,\n  permitSignature.s,\n];\nconst permitHook = {\n  target: USDC.address,\n  callData: USDC.interface.encodeFunctionData("permit", permitParams),\n  gasLimit: `${await USDC.estimateGas.permit(...permitParams)}`,\n};\nconsole.log("permit hook:", permitHook);\n\n/*** Bridging ***/\n\norderConfig.receiver = await BRIDGER.getAccountAddress(wallet.address);\nconst bridgeHook = {\n  target: BRIDGER.address,\n  callData: BRIDGER.interface.encodeFunctionData("bridgeAll", [\n    wallet.address,\n    COW.address,\n  ]),\n  // Approximate gas limit determined with Tenderly.\n  gasLimit: "228533",\n};\nconsole.log("bridge hook:", bridgeHook);\n\n/*** Order Creation ***/\n\norderConfig.appData = JSON.stringify({\n  metadata: {\n    hooks: {\n      pre: [permitHook],\n      post: [bridgeHook],\n    },\n  },\n});\nconst { id: quoteId, quote } = await fetch(\n  "https://barn.api.cow.fi/mainnet/api/v1/quote",\n  {\n    method: "POST",\n    headers: {\n      "content-type": "application/json",\n    },\n    body: JSON.stringify({\n      from: wallet.address,\n      sellAmountBeforeFee: orderConfig.sellAmount,\n      ...orderConfig,\n    }),\n  },\n).then((response) => response.json());\nconsole.log("quote:", quoteId, quote);\n\nconst orderData = {\n  ...orderConfig,\n  sellAmount: quote.sellAmount,\n  buyAmount: `${ethers.BigNumber.from(quote.buyAmount).mul(99).div(100)}`,\n  validTo: quote.validTo,\n  appData: ethers.utils.id(orderConfig.appData),\n  feeAmount: quote.feeAmount,\n};\nconst orderSignature = await wallet._signTypedData(\n  {\n    name: "Gnosis Protocol",\n    version: "v2",\n    chainId,\n    verifyingContract: SETTLEMENT.address,\n  },\n  {\n    Order: [\n      { name: "sellToken", type: "address" },\n      { name: "buyToken", type: "address" },\n      { name: "receiver", type: "address" },\n      { name: "sellAmount", type: "uint256" },\n      { name: "buyAmount", type: "uint256" },\n      { name: "validTo", type: "uint32" },\n      { name: "appData", type: "bytes32" },\n      { name: "feeAmount", type: "uint256" },\n      { name: "kind", type: "string" },\n      { name: "partiallyFillable", type: "bool" },\n      { name: "sellTokenBalance", type: "string" },\n      { name: "buyTokenBalance", type: "string" },\n    ],\n  },\n  orderData,\n);\n\nconst orderUid = await fetch(\n  "https://barn.api.cow.fi/mainnet/api/v1/orders",\n  {\n    method: "POST",\n    headers: {\n      "content-type": "application/json",\n    },\n    body: JSON.stringify({\n      ...orderData,\n      from: wallet.address,\n      appData: orderConfig.appData,\n      appDataHash: orderData.appData,\n      signingScheme: "eip712",\n      signature: orderSignature,\n      quoteId,\n    }),\n  },\n).then((response) => response.json());\nconsole.log("order:", orderUid);\n')))}u.isMDXComponent=!0}}]);